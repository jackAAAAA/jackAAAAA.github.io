<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>头脑中一些模糊概念与Claude 3.5 Sonnet的讨论 | jackAAAAA's Blog</title><meta name="author" content="JackAAAAA"><meta name="copyright" content="JackAAAAA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="与Claude 3.5 Sonnet的讨论">
<meta property="og:type" content="article">
<meta property="og:title" content="头脑中一些模糊概念与Claude 3.5 Sonnet的讨论">
<meta property="og:url" content="http://example.com/posts/de362e30.html">
<meta property="og:site_name" content="jackAAAAA&#39;s Blog">
<meta property="og:description" content="与Claude 3.5 Sonnet的讨论">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-07-08T11:06:04.000Z">
<meta property="article:modified_time" content="2024-07-08T12:18:06.786Z">
<meta property="article:author" content="JackAAAAA">
<meta property="article:tag" content="Claude">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="计算机科学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/de362e30.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: JackAAAAA","link":"链接: ","source":"来源: jackAAAAA's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '头脑中一些模糊概念与Claude 3.5 Sonnet的讨论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-07-08 20:18:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script>[object Object]<meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="jackAAAAA's Blog"><img class="site-icon" src="https://cdn.discordapp.com/attachments/1235036768898781255/1235050492300759131/smithstephanie9186_A_vivid_spring_landscape_blooming_flowers_of_d7e17e3a-e6d0-40de-925c-e5cd3f3220d5.png?ex=66417667&amp;is=664024e7&amp;hm=51725b9743e872c4e58e44f67061f49b04bd55d6293a41c4f9329187b5b18146&amp;"/><span class="site-name">jackAAAAA's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">头脑中一些模糊概念与Claude 3.5 Sonnet的讨论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-08T11:06:04.000Z" title="发表于 2024-07-08 19:06:04">2024-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-08T12:18:06.786Z" title="更新于 2024-07-08 20:18:06">2024-07-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="头脑中一些模糊概念与Claude 3.5 Sonnet的讨论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>IdleHandler的实现原理应用场景</p>
<p>IdleHandler是Android中一种用于处理空闲时间的机制,它的主要实现原理和应用场景如下:</p>
<p>实现原理:</p>
<p>IdleHandler是通过MessageQueue实现的。MessageQueue维护了一个IdleHandler列表。</p>
<p>当Looper处理完所有消息后,会调用MessageQueue的next()方法获取下一条消息。</p>
<p>如果队列中没有消息或者下一条消息还没到执行时间,就会进入idle状态。</p>
<p>此时会遍历IdleHandler列表,依次调用每个IdleHandler的queueIdle()方法。</p>
<p>queueIdle()返回false表示使用一次后移除,返回true表示继续保留以便下次idle时执行。</p>
<p>执行完IdleHandler后,如果仍然idle就会进入阻塞等待状态。</p>
<p>应用场景:</p>
<p>延迟执行不紧急的任务:<br>可以把一些不紧急的初始化、数据处理等任务放到IdleHandler中执行,避免在启动时就做大量工作影响性能。</p>
<p>性能优化:<br>把一些耗时较长但不紧急的操作放到空闲时间执行,提高应用响应速度。</p>
<p>资源回收:<br>在空闲时进行一些资源清理、缓存淘汰等工作。</p>
<p>预加载:<br>利用空闲时间提前加载一些数据或资源,提高后续操作的响应速度。</p>
<p>数据同步:<br>在空闲时进行本地数据与服务器的同步操作。</p>
<p>监控统计:<br>利用空闲时间收集和上报一些统计数据。</p>
<p>优化动画:<br>在动画执行的空隙插入一些次要的UI更新操作。</p>
<p>使用示例:</p>
<p>Copy<br>Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler()<br>                    {<br>                    @Override<br>                    public boolean queueIdle() {<br>                    &#x2F;&#x2F; 执行空闲时的任务<br>                    doSomeWork();<br>                    &#x2F;&#x2F; 返回false表示只执行一次<br>                    return false;<br>                    }<br>                    });</p>
<p>注意事项:</p>
<p>IdleHandler中不应执行耗时很长的操作,否则可能影响主线程的其他任务。</p>
<p>不要在IdleHandler中再次加入消息或者post Runnable,可能导致死循环。</p>
<p>谨慎使用返回true的情况,避免频繁执行导致性能问题。</p>
<p>IdleHandler在应用切换到后台时可能不会执行,如果有必要可以结合Lifecycle使用。</p>
<p>总之,IdleHandler是一个很有用的机制,合理使用可以优化应用性能,提高用户体验。但也需要谨慎使用,避免引入新的问题。</p>
<p>你可以把你阐述的原理配合源码来给我讲述吗？我感觉还是没有理解</p>
<p>当然可以。让我们通过 Android 的源码来深入理解 IdleHandler 的实现原理。我们主要关注 MessageQueue 类，因为 IdleHandler 的核心实现就在这里。</p>
<p>首先，让我们看看 MessageQueue 类中与 IdleHandler 相关的部分：</p>
<p>Copy<br>public final class MessageQueue {<br>                    private final<br>                    ArrayList<IdleHandler> mIdleHandlers &#x3D; new ArrayList<IdleHandler>();<br>                    private IdleHandler[] mPendingIdleHandlers;<br>                    private boolean mQuitting;</p>
<pre><code>                // ...其他代码...

                public void addIdleHandler(@NonNull IdleHandler handler) &#123;
                if (handler == null) &#123;
                throw new NullPointerException(&quot;Can&#39;t add a null
                  IdleHandler&quot;);
                &#125;
                synchronized (this) &#123;
                mIdleHandlers.add(handler);
                &#125;
                &#125;

                public void removeIdleHandler(@NonNull IdleHandler handler) &#123;
                synchronized (this) &#123;
                mIdleHandlers.remove(handler);
                &#125;
                &#125;

                // ...其他代码...
                &#125;
              
</code></pre>
<p>这里我们可以看到，MessageQueue 维护了一个 IdleHandler 的列表 mIdleHandlers。</p>
<p>现在，让我们看看 MessageQueue 的 next() 方法，这是 IdleHandler 被调用的关键地方：</p>
<p>Copy<br>Message next() {<br>                    &#x2F;&#x2F; …前面的代码…</p>
<pre><code>                for (;;) &#123;
                // ...其他代码...

                nativePollOnce(ptr, nextPollTimeoutMillis);

                synchronized (this) &#123;
                // ...获取下一条消息的代码...

                // 如果没有更多消息，我们就处于空闲状态
                if (msg == null) &#123;
                // 没有消息意味着我们现在处于空闲状态
                pendingIdleHandlerCount = -1;
                nextPollTimeoutMillis = -1;
                &#125; else &#123;
                // 如果有延迟消息，我们就设置一个超时
                nextPollTimeoutMillis = 0;
                &#125;

                if (pendingIdleHandlerCount &lt; 0
                &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;
                pendingIdleHandlerCount = mIdleHandlers.size();
                &#125;
                if (pendingIdleHandlerCount &lt;= 0) &#123;
                // 没有 idle handlers 需要运行
                mBlocked = true;
                continue;
                &#125;

                if (mPendingIdleHandlers == null) &#123;
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                &#125;
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
                &#125;

                // 运行 idle handlers
                for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; //
                  释放引用

                boolean keep = false;
                try &#123;
                keep = idler.queueIdle();
                &#125; catch (Throwable t) &#123;
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
                &#125;

                if (!keep) &#123;
                synchronized (this) &#123;
                mIdleHandlers.remove(idler);
                &#125;
                &#125;
                &#125;

                // 重置 idle handler 计数为 0，这样我们就不会再次运行它们
                pendingIdleHandlerCount = 0;

                // 当调用一个空闲处理程序时，新消息可能已经到达，所以回到循环顶部去检查
                nextPollTimeoutMillis = 0;
                &#125;
                &#125;
              
</code></pre>
<p>让我们逐步解析这段代码：</p>
<p>当 MessageQueue 中没有消息或下一条消息还没到执行时间时，msg &#x3D;&#x3D; null。</p>
<p>此时，我们设置 pendingIdleHandlerCount 为 IdleHandler 的数量。</p>
<p>如果有 IdleHandler 需要运行，我们就把它们复制到 mPendingIdleHandlers 数组中。</p>
<p>然后，我们遍历这个数组，对每个 IdleHandler 调用其 queueIdle() 方法。</p>
<p>如果 queueIdle() 返回 false，我们就从 mIdleHandlers 列表中移除这个 IdleHandler。</p>
<p>执行完所有的 IdleHandler 后，我们重置 pendingIdleHandlerCount 为 0。</p>
<p>最后，我们设置 nextPollTimeoutMillis &#x3D; 0，这样就会立即再次检查消息队列，因为在执行 IdleHandler 的过程中可能有新消息到达。</p>
<p>这个实现确保了：</p>
<p>IdleHandler 只在消息队列空闲时被调用。<br>每次进入空闲状态时，所有的 IdleHandler 都会被调用一次。<br>IdleHandler 可以选择是一次性的（返回 false）还是重复的（返回 true）。<br>在执行 IdleHandler 后，会立即再次检查消息队列，保证及时处理新到达的消息。<br>通过这种方式，Android 系统提供了一种机制，允许开发者在主线程空闲时执行一些不紧急的任务，而不会影响到主线程的响应性。这就是 IdleHandler 的核心实现原理。</p>
<p>你说一下一般在哪里用IdleHandler，给一个示例代码</p>
<p>IdleHandler 通常在需要执行一些不紧急任务，但又希望不影响主线程性能的场景下使用。以下是一些常见的使用场景和示例代码：</p>
<p>应用启动时的延迟初始化<br>在应用启动时，可能有一些组件或功能不需要立即初始化，可以使用 IdleHandler 在主线程空闲时进行初始化。</p>
<p>Copy<br>public class MyApplication extends Application {<br>                    @Override<br>                    public void onCreate() {<br>                    super.onCreate();</p>
<pre><code>                // 立即需要的初始化
                // ...

                // 使用 IdleHandler 延迟初始化
                Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;
                @Override
                public boolean queueIdle() &#123;
                // 执行延迟初始化任务
                initNonEssentialComponents();
                // 返回 false，表示只执行一次
                return false;
                &#125;
                &#125;);
                &#125;

                private void initNonEssentialComponents()
                &#123;
                // 初始化不是立即需要的组件
                &#125;
                &#125;
              
</code></pre>
<p>复杂 UI 的分步加载<br>在加载复杂 UI 时，可以使用 IdleHandler 分步加载，避免一次性加载导致卡顿。</p>
<p>Copy<br>public class ComplexActivity extends AppCompatActivity {<br>                    private int currentStep &#x3D; 0;<br>                    private final int TOTAL_STEPS &#x3D; 5;</p>
<pre><code>                @Override
                protected void onCreate(Bundle
                  savedInstanceState) &#123;
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_complex);

                loadUIStep();
                &#125;

                private void loadUIStep() &#123;
                Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;
                @Override
                public boolean queueIdle() &#123;
                if (currentStep &lt; TOTAL_STEPS) &#123;
                // 加载 UI 的下一步
                loadNextUIPart();
                currentStep++;
                // 返回 true，继续执行下一步
                return true;
                &#125; else &#123;
                // 所有步骤完成
                return false;
                &#125;
                &#125;
                &#125;);
                &#125;

                private void loadNextUIPart() &#123;
                // 根据 currentStep 加载相应的 UI 部分
                switch (currentStep) &#123;
                case 0:
                // 加载第一部分 UI
                break;
                case 1:
                // 加载第二部分 UI
                break;
                // ... 其他步骤
                &#125;
                &#125;
                &#125;
              
</code></pre>
<p>预加载或缓存数据<br>在应用空闲时预加载一些数据或更新缓存。</p>
<p>Copy<br>public class DataManager {<br>                    public void setupPreloading(Context<br>                      context) {<br>                    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {<br>                    @Override<br>                    public boolean queueIdle() {<br>                    if (needToPreloadData()) {<br>                    preloadData();<br>                    &#x2F;&#x2F; 如果还有数据需要预加载，返回 true<br>                    return true;<br>                    }<br>                    if (needToUpdateCache()) {<br>                    updateCache();<br>                    &#x2F;&#x2F; 如果还需要继续更新缓存，返回 true<br>                    return true;<br>                    }<br>                    &#x2F;&#x2F; 所有预加载和缓存更新完成<br>                    return false;<br>                    }<br>                    });<br>                    }</p>
<pre><code>                private boolean needToPreloadData() &#123;
                // 检查是否需要预加载数据
                return false;
                &#125;

                private void preloadData() &#123;
                // 预加载数据的逻辑
                &#125;

                private boolean needToUpdateCache() &#123;
                // 检查是否需要更新缓存
                return false;
                &#125;

                private void updateCache() &#123;
                // 更新缓存的逻辑
                &#125;
                &#125;
              
</code></pre>
<p>性能监控<br>使用 IdleHandler 在空闲时收集和处理性能数据。</p>
<p>Copy<br>public class PerformanceMonitor {<br>                    public void startMonitoring() {<br>                    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {<br>                    @Override<br>                    public boolean queueIdle() {<br>                    collectPerformanceData();<br>                    &#x2F;&#x2F; 持续监控，返回 true<br>                    return true;<br>                    }<br>                    });<br>                    }</p>
<pre><code>                private void collectPerformanceData() &#123;
                // 收集性能数据的逻辑
                // 例如：内存使用、CPU 使用等
                &#125;
                &#125;
              
</code></pre>
<p>这些示例展示了 IdleHandler 在不同场景下的使用方法。关键是要记住，IdleHandler 中的操作应该是轻量级的，不应该执行耗时很长的任务，否则可能会影响主线程的响应性。如果需要执行重量级任务，应考虑使用后台线程。</p>
<p>我有以下洞察：1.Android应用程序本质是一个UI主线程 + 多个子线程组成的 2.在Android Studio示例项目Hello World是只有一个UI主线程的应用 3.Android的UI主线程刷新全靠其中的Handler机制 4.所谓Handler机制就是多个Handler向主线程对应的MessageQueue发送Message，这里的Handler可以是主线程的，也可以是其他子线程的；然后，主线程对应的Looper从这个MessageQueue取出Message交给对应的渲染Handler进行处理，放到对应的window进行渲染刷新 我的这些洞察正确吗？</p>
<p>您的洞察基本正确，但有一些地方需要稍微调整或补充。让我逐点分析：</p>
<p>正确。Android 应用程序确实由一个 UI 主线程（也称为主线程或 UI 线程）和可能的多个子线程组成。</p>
<p>基本正确。即使是最简单的 Hello World 项目，也不仅仅只有一个 UI 主线程。虽然你可能只看到了主线程的代码，但实际上 Android 系统会为应用创建其他线程，如 GC 线程、JIT 编译线程等。不过，从应用开发者的角度来看，你主要关注的确实是 UI 主线程。</p>
<p>部分正确。Android 的 UI 主线程不仅依赖于 Handler 机制来刷新。UI 更新确实通常通过 Handler 发送到主线程，但 UI 刷新还涉及到 View 系统的 measure、layout、draw 过程，以及 Choreographer 的 VSYNC 同步机制等。</p>
<p>这个描述大体正确，但有一些细节需要澄清：</p>
<p>Handler 通常与特定线程的 Looper 关联，而不是直接向 MessageQueue 发送消息。Handler 创建 Message 并通过与之关联的 Looper 将消息发送到 MessageQueue。<br>主线程的 Looper 确实从 MessageQueue 中取出消息并分发给对应的 Handler 处理。<br>不是所有的 Message 都与 UI 渲染相关。消息可能是执行任何类型的任务，包括但不限于 UI 更新。<br>UI 更新通常是通过 invalidate() 或 requestLayout() 等方法触发的，这会导致 View 系统在下一个 frame 进行重绘或重新布局。<br>补充说明：</p>
<p>Android 的 UI 更新遵循单线程模型，所有的 UI 操作都必须在主线程上执行。<br>除了 Handler 机制，Android 还提供了其他方式在主线程上执行代码，如 View.post() 方法和 Activity.runOnUiThread() 方法。<br>Looper、Handler 和 MessageQueue 共同构成了 Android 的消息机制，这不仅用于 UI 更新，还用于线程间通信和任务调度。<br>实际的 UI 渲染过程涉及到更多底层机制，包括硬件加速、GPU 渲染等。<br>总的来说，您的理解抓住了 Android 系统的一些核心概念，这是一个很好的起点。继续深入学习，您会发现 Android 系统的复杂性和精妙之处。</p>
<p>我有以下洞察，请帮我看看是否正确？如果正确，请看看描述是否准确？1.Handler机制的本质就是Android线程间的一种通信方式 2.Handler机制相较于其他线程间通信方式的区别在于它可以更新UI，而其他的通信方式不可以</p>
<p>您的洞察基本正确，但需要一些细微的调整和补充。让我们逐点分析：</p>
<p>“Handler机制的本质就是Android线程间的一种通信方式”</p>
<p>这个洞察是正确的。Handler 机制确实是 Android 中用于线程间通信的一种重要方式。它允许不同线程之间发送和处理消息，从而实现线程间的数据传递和任务调度。</p>
<p>描述可以稍微调整为：<br>“Handler 机制是 Android 中实现线程间通信的一种核心机制，它通过消息队列实现了异步消息的处理和线程间的任务调度。”</p>
<p>“Handler机制相较于其他线程间通信方式的区别在于它可以更新UI，而其他的通信方式不可以”</p>
<p>这个洞察部分正确，但需要一些澄清：</p>
<p>Handler 机制确实常用于在主线程（UI 线程）上更新 UI，但这不是 Handler 机制独有的特性。<br>Handler 机制之所以常用于 UI 更新，是因为 Android 的主线程默认就有一个 Looper 在运行，使得使用 Handler 进行 UI 更新变得非常方便。<br>其他线程间通信方式（如 AsyncTask、Runnable 配合 runOnUiThread()）也可以用于更新 UI。<br>更准确的描述可能是：<br>“Handler 机制是 Android 中常用于 UI 更新的线程间通信方式，因为它与 Android 的消息循环系统紧密集成，特别适合在主线程（UI 线程）上执行任务。然而，它并不是唯一可以更新 UI 的方式，其他机制如 View.post()、Activity.runOnUiThread() 等也可以用于 UI 更新。Handler 的优势在于它提供了一个灵活的消息处理框架，适用于各种异步操作和线程间通信场景。”</p>
<p>总结：<br>您的洞察抓住了 Handler 机制的核心特性和常见用途。Handler 确实是一种重要的线程间通信方式，并且在 Android 开发中经常用于 UI 更新。但重要的是要理解，它的功能不仅限于 UI 更新，而且也不是唯一可以更新 UI 的方式。Handler 机制的强大之处在于它提供了一个灵活、高效的消息处理框架，可以用于各种异步编程场景。</p>
<p>但是View.post()、Activity.runOnUiThread() 的底层不也是用的Handler来实现的吗？我才这么说的</p>
<p>您说得非常对！这是一个非常敏锐和正确的观察。我为之前没有明确指出这一点而道歉。您完全正确，View.post() 和 Activity.runOnUiThread() 的底层实现确实都是基于 Handler 机制的。让我们更详细地看一下：</p>
<p>View.post()<br>当你调用 View.post() 时，如果 View 已经附加到窗口，它会直接使用关联的 Handler 来发布 Runnable。如果 View 还没有附加到窗口，它会将 Runnable 添加到一个队列中，等到 View 被附加时再通过 Handler 执行。</p>
<p>Activity.runOnUiThread()<br>这个方法检查当前是否在主线程，如果是，就直接运行 Runnable。如果不是，它会使用 Activity 的 Handler 将 Runnable 发布到主线程的消息队列中。</p>
<p>您的理解是正确的，这些方法本质上都是 Handler 机制的封装，提供了更方便的 API 来在主线程上执行代码。</p>
<p>考虑到这一点，我们可以更准确地描述为：</p>
<p>“Handler 机制是 Android 中实现线程间通信和 UI 更新的基础机制。许多常用的 UI 更新方法，如 View.post()、Activity.runOnUiThread() 等，实际上都是在底层使用 Handler 来实现的。Handler 提供了一个统一的消息处理框架，不仅直接用于线程间通信，还被 Android 框架广泛用于封装更高级、更方便的 API，使得在主线程（UI 线程）上执行任务变得简单直接。”</p>
<p>感谢您指出这一点，这确实是理解 Android 消息机制的一个重要方面。您的观察展示了对 Android 系统内部工作原理的深入理解。</p>
<p>Handler与MessageQueue的通信方式是不是就两种？一是通过sendMessage发送Message到MessageQueue; 二是通过post将Runnable发送到MessageQueue。如果是第一种方式那么，我们就要重写handleMessage方法，类似如下代码：public class MainActivity extends AppCompatActivity {</p>
<p>private Handler mainHandler;</p>
<pre><code>              @Override
              protected void onCreate(Bundle savedInstanceState) &#123;
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);

              mainHandler = new Handler(Looper.getMainLooper()) &#123;
              @Override
              public void handleMessage(Message msg) &#123;
              // 更新UI
              TextView textView = findViewById(R.id.textView);
              textView.setText(&quot;Updated from background thread!&quot;);
              &#125;
              &#125;;

              // 启动子线程
              new Thread(new Runnable() &#123;
              @Override
              public void run() &#123;
              // 模拟耗时操作
              SystemClock.sleep(2000);

              // 向主线程发送消息
              mainHandler.sendEmptyMessage(0);
              &#125;
              &#125;).start();
              &#125;
            
</code></pre>
<p>}<br>；如果是第二种的话，我们就玩玩不用写类似handleMessage的回调，因为我们post的Runnable其实就是我们要进行的UI操作了。我的理解正确且准确吗？</p>
<p>您的理解基本正确，但还可以稍微补充和细化一些。让我们逐点分析：</p>
<p>Handler 与 MessageQueue 的通信方式<br>您提到的两种方式确实是最常用的：</p>
<p>通过 sendMessage 系列方法发送 Message<br>通过 post 系列方法发送 Runnable<br>这是正确的，但还可以补充一点：实际上，post 方法内部也是创建了一个 Message 对象，只是这个 Message 的 callback 字段被设置为传入的 Runnable。所以从底层实现来看，这两种方式最终都是向 MessageQueue 发送 Message。</p>
<p>处理消息的方式<br>您的理解是正确的：</p>
<p>对于 sendMessage 方式，我们通常需要重写 handleMessage 方法来处理接收到的 Message。<br>对于 post 方式，我们直接在 Runnable 中定义要执行的操作，不需要额外的回调方法。<br>您提供的代码示例很好地展示了 sendMessage 的使用方式。</p>
<p>补充说明<br>Handler 还有其他发送消息的方法，如 sendMessageDelayed、postDelayed 等，用于延迟发送消息或执行任务。<br>虽然 post 方法不需要重写 handleMessage，但它实际上是通过 Handler 的 dispatchMessage 方法来执行 Runnable 的。<br>在使用 sendMessage 时，除了重写 handleMessage，还可以在创建 Handler 时传入一个 Handler.Callback 对象，这提供了另一种处理消息的方式。<br>更准确的描述<br>“Handler 与 MessageQueue 的通信主要通过两种方式：发送 Message 和发送 Runnable。发送 Message 通常需要重写 handleMessage 方法来处理消息，而发送 Runnable 则直接在 Runnable 中定义要执行的操作。尽管表面上看起来不同，但这两种方式在底层都是通过向 MessageQueue 发送 Message 对象来实现的。选择哪种方式主要取决于具体的使用场景和代码组织方式。”</p>
<p>总的来说，您的理解是正确的，并且您提供的代码示例很好地说明了 sendMessage 的使用方式。您的观察显示了对 Android 消息机制的深入理解。</p>
<p>那什么时候使用sendMessage，什么时候使用Post?</p>
<p>选择使用 sendMessage 还是 post 主要取决于具体的使用场景和代码组织方式。以下是一些指导原则和常见的使用场景：</p>
<p>使用 sendMessage 的情况：</p>
<p>需要处理多种类型的消息：<br>当你的 Handler 需要处理多种不同类型的消息时，sendMessage 更适合。你可以使用 Message 的 what 字段来区分不同类型的消息。</p>
<p>Copy<br>handler.sendMessage(Message.obtain(handler, MSG_TYPE_1,<br>                        data));<br>                        handler.sendMessage(Message.obtain(handler, MSG_TYPE_2, data));</p>
<pre><code>                    @Override
                    public void handleMessage(Message
                      msg) &#123;
                    switch (msg.what) &#123;
                    case MSG_TYPE_1:
                    // 处理类型1消息
                    break;
                    case MSG_TYPE_2:
                    // 处理类型2消息
                    break;
                    &#125;
                    &#125;
                  
</code></pre>
<p>需要传递复杂数据：<br>Message 对象可以携带更多的数据（arg1, arg2, obj 等），适合传递复杂的数据结构。</p>
<p>Copy<br>Message msg &#x3D; Message.obtain();<br>                        msg.what &#x3D; MSG_UPDATE_PROGRESS;<br>                        msg.arg1 &#x3D; progress;<br>                        msg.obj &#x3D; someData;<br>                        handler.sendMessage(msg);</p>
<p>需要延迟执行或重复执行：<br>虽然 post 也支持延迟执行，但对于需要取消或修改的延迟任务，使用 sendMessage 可能更方便。</p>
<p>Copy<br>handler.sendMessageDelayed(Message.obtain(handler,<br>                        MSG_DO_SOMETHING), 1000);</p>
<p>在不同的类中处理消息：<br>如果你想在不同的类中处理消息，可以创建一个自定义的 Handler 子类，并在多个地方重用。</p>
<p>使用 post 的情况：</p>
<p>简单的一次性任务：<br>当你只需要执行一个简单的操作，不需要复杂的消息传递时，post 更简洁。</p>
<p>Copy<br>handler.post(new Runnable() {<br>                        @Override<br>                        public void run() {<br>                        updateUI();<br>                        }<br>                        });</p>
<p>代码逻辑较为独立：<br>如果任务的逻辑相对独立，不需要与 Handler 的其他部分交互，使用 post 可以使代码更加模块化。</p>
<p>Lambda 表达式友好：<br>在使用 Java 8+ 或 Kotlin 时，post 方法配合 Lambda 表达式使用非常简洁。</p>
<p>Copy<br>handler.post(() -&gt; textView.setText(“Updated”));</p>
<p>临时性或匿名的操作：<br>对于一些不需要重复使用的临时性操作，post 更为方便。</p>
<p>不需要区分消息类型：<br>当所有的任务都是同类型的，不需要区分处理时，post 更简单直接。</p>
<p>总结：</p>
<p>如果需要处理多种类型的消息，传递复杂数据，或者需要更细粒度的控制（如取消消息），使用 sendMessage。<br>如果是简单的一次性任务，或者任务逻辑相对独立，使用 post 会更加简洁和直观。<br>最终，选择哪种方式还是要根据具体的应用场景和个人&#x2F;团队的编码风格来决定。两种方式都有其适用的场景，关键是选择最适合当前需求的方式。</p>
<p>假设现在有这样一个需求Android App开发需求：我想实现上传手机系统相册的图片或者视频到服务器。那么我把我需要做的工作拆分成1.利用一个进程间通信（我的App进程与系统相册进程进行通信）获取到系统相册的图片或者视频数据列表（其中这个进程间通信是我在App中进行UI点击之后，UI线程创建一个子线程去做的，如果获取到Android系统返回的图片和视频列表，我的子线程会通知我APP的UI主线程进行列表刷新，这里就涉及到不同程序的进程间通信以及同一个程序的线程间通信）2.当我在UI列表刷新这个Activity中选择某几张图片过后又跳转到另外一个Activity，这里应该没有涉及到线程或者进程间通信（因为这是在我的App中进行的，并没有切换进程，只是UI显示改变，因此也不涉及线程切换）3.当我跳转到第二步所说的新Activity之后，再点击 发表 这样UI按钮的时候，UI主线程会创建一个子线程去进行网络请求，这里涉及到UI主线程和子线程的通信，当这个子线程网络请求成功或者失败之后会通知主线程进行UI刷新，这里又涉及到子线程与主线程的线程间通信。我的思路和理解正确且准确吗？</p>
<p>您的思路和理解基本正确，而且分析得很详细。让我们逐步分析您的思路，并对一些细节进行补充和澄清：</p>
<p>获取系统相册的图片或视频数据列表：<br>您的理解大体正确，但有几点需要澄清：</p>
<p>在 Android 中，获取系统相册内容通常不需要进程间通信。Android 提供了内容提供者（Content Provider）机制，允许应用访问其他应用（包括系统应用）的数据，而无需直接的进程间通信。<br>您可以使用 MediaStore API 或 Storage Access Framework 来访问系统相册内容。<br>确实需要在子线程中进行数据查询，然后通过 Handler 或其他机制通知主线程更新 UI。<br>在 App 内跳转到新的 Activity：<br>您的理解完全正确：</p>
<p>这是 App 内部的 Activity 跳转，不涉及进程间通信。<br>也不涉及特殊的线程切换，因为 Activity 的生命周期方法都是在主线程中调用的。<br>在新 Activity 中上传图片&#x2F;视频：<br>您的理解也是正确的：</p>
<p>网络请求应该在子线程中进行。<br>子线程完成网络请求后，需要通过某种机制（如 Handler）通知主线程更新 UI。<br>补充说明：</p>
<p>关于获取相册内容：</p>
<p>使用 ContentResolver 查询 MediaStore：<br>Copy<br>ContentResolver resolver &#x3D;<br>                            getContentResolver();<br>                            Uri uri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;<br>                            Cursor cursor &#x3D; resolver.query(uri, null,<br>                            null, null, null);</p>
<p>这个操作应在子线程中进行，然后使用 Handler 或 runOnUiThread 更新 UI。<br>Activity 间传递数据：</p>
<p>可以使用 Intent 携带数据，或者使用 ViewModel 等架构组件在 Activity 间共享数据。<br>上传操作：</p>
<p>可以使用 AsyncTask、Thread + Handler、或现代的协程（Kotlin）来处理。<br>考虑使用 Service 来处理长时间运行的上传任务，特别是如果希望上传在后台继续。<br>权限处理：</p>
<p>别忘了请求必要的权限，如 READ_EXTERNAL_STORAGE。<br>错误处理和用户体验：</p>
<p>确保在各个步骤中都有适当的错误处理和用户反馈。<br>示例代码结构：</p>
<p>Copy<br>public class GalleryActivity extends AppCompatActivity {<br>                    private Handler mainHandler &#x3D; new Handler(Looper.getMainLooper());</p>
<pre><code>                @Override
                protected void onCreate(Bundle
                  savedInstanceState) &#123;
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_gallery);

                loadGalleryContent();
                &#125;

                private void loadGalleryContent() &#123;
                new Thread(() -&gt; &#123;
                // 查询 MediaStore
                List&lt;MediaItem&gt; mediaItems = queryMediaStore();

                // 在主线程更新 UI
                mainHandler.post(() -&gt; updateUI(mediaItems));
                &#125;).start();
                &#125;

                private List&lt;MediaItem&gt; queryMediaStore() &#123;
                // 实现 MediaStore 查询逻辑
                // ...
                &#125;

                private void updateUI(List&lt;MediaItem&gt;
                  items) &#123;
                // 更新 RecyclerView 或其他 UI 组件
                &#125;
                &#125;

                public class UploadActivity extends AppCompatActivity &#123;
                private Handler mainHandler = new Handler(Looper.getMainLooper());

                public void onUploadClick(View view) &#123;
                new Thread(() -&gt; &#123;
                // 执行上传操作
                boolean success = uploadMedia();

                // 在主线程更新 UI
                mainHandler.post(() -&gt; showUploadResult(success));
                &#125;).start();
                &#125;

                private boolean uploadMedia() &#123;
                // 实现上传逻辑
                // ...
                &#125;

                private void showUploadResult(boolean success) &#123;
                // 显示上传结果
                &#125;
                &#125;
              
</code></pre>
<p>总的来说，您的理解和分析是正确的，展示了对 Android 多线程编程和 UI 更新机制的良好理解。实际实现时，可能还需要考虑更多细节，如错误处理、生命周期管理等，但您的基本思路是正确的。</p>
<p>在 Android 中，获取系统相册内容通常不需要进程间通信，为什么这么说？我的App和系统程序不是在不同的进程中吗？如果是在不同的进程中，为啥不涉及进程间通信？</p>
<p>您提出了一个非常好的问题，这确实需要进一步解释。您是对的，您的应用和系统相册应用确实运行在不同的进程中。然而，当我们说”不需要进程间通信”时，我们指的是不需要直接的、显式的进程间通信。让我解释一下为什么是这样：</p>
<p>Content Provider 机制<br>Android 使用 Content Provider 机制来实现跨进程数据共享。这是一种由系统管理的、封装了进程间通信细节的机制。当你的应用通过 ContentResolver 查询 MediaStore（系统的媒体内容提供者）时，底层确实发生了进程间通信，但这个过程对开发者是透明的。</p>
<p>Binder IPC<br>Content Provider 在底层使用了 Binder IPC（进程间通信）机制。Binder 是 Android 特有的 IPC 机制，它被设计成对应用开发者透明的。当你调用 ContentResolver 的方法时，系统会自动处理必要的 IPC 调用。</p>
<p>抽象层<br>ContentResolver 和 ContentProvider 提供了一个抽象层，使得跨进程访问数据看起来就像是在访问本地数据一样。这个抽象层隐藏了底层的 IPC 细节。</p>
<p>系统级别的优化<br>Android 系统对这种常见的跨进程数据访问进行了优化，使得整个过程对开发者来说更加简单和高效。</p>
<p>与传统 IPC 的对比<br>当我们说”不需要进程间通信”时，我们通常是在对比传统的、显式的 IPC 方法，如套接字、共享内存等。使用 Content Provider 不需要开发者手动设置这些 IPC 机制。</p>
<p>示例说明：</p>
<p>Copy<br>&#x2F;&#x2F; 这段代码看起来像是在查询本地数据，但实际上涉及了跨进程通信<br>                    ContentResolver resolver &#x3D; getContentResolver();<br>                    Uri uri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;<br>                    Cursor cursor &#x3D; resolver.query(uri, null, null, null, null);</p>
<p>在这个例子中，虽然代码看起来很简单，但在底层，它涉及了：</p>
<p>你的应用进程<br>系统服务进程（ActivityManagerService）<br>媒体存储进程（运行 MediaProvider 的进程）<br>这些进程之间的通信都是由 Android 系统自动处理的。</p>
<p>总结：<br>虽然从技术上讲，访问系统相册确实涉及进程间通信，但 Android 通过 Content Provider 机制提供了一个高度抽象和优化的接口，使得开发者可以像访问本地数据一样访问其他进程的数据，而无需关心底层的 IPC 细节。这就是为什么我们说”通常不需要进程间通信”，因为从开发者的角度来看，我们不需要显式地实现 IPC。</p>
<p>那什么时候需要显示实现IPC呢？比如我想实现一个分享功能，比如从我的App生成的一张海报跳转到微信或者飞书等其他App；又或者我在我的App的WebView打开了一个小红书视频网页，然后在上面的网页点击了某一个按钮，弹出提示跳转到小红书。这些功能的实现应该都需要进程间通信吧？</p>
<p>您提出了一个非常好的问题。确实，在某些情况下，我们需要更直接地处理进程间通信。不过，在您提到的这些场景中，Android 系统仍然为我们提供了一些高级抽象，使得大多数情况下我们不需要直接实现底层的 IPC 机制。让我们逐一分析这些场景：</p>
<p>分享功能（从您的 App 分享到微信或飞书）<br>这种情况通常使用 Android 的 Intent 机制，这是一种由系统管理的 IPC 抽象：</p>
<p>Copy<br>Intent shareIntent &#x3D; new Intent(Intent.ACTION_SEND);<br>                    shareIntent.setType(“image&#x2F;*”);<br>                    Uri imageUri &#x3D; Uri.parse(“path_to_your_poster_image”);<br>                    shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);<br>                    startActivity(Intent.createChooser(shareIntent, “Share via”));</p>
<p>虽然这涉及跨进程通信，但 Intent 机制隐藏了底层的 IPC 细节。</p>
<p>从 WebView 跳转到小红书 App<br>这种情况通常通过 Deep Linking 或 App Links 实现：</p>
<p>Copy<br>webView.setWebViewClient(new<br>                    WebViewClient() {<br>                    @Override<br>                    public boolean shouldOverrideUrlLoading(WebView<br>                      view, String url) {<br>                    if (url.startsWith(“xiaohongshu:&#x2F;&#x2F;“)) {<br>                    Intent intent &#x3D; new Intent(Intent.ACTION_VIEW, Uri.parse(url));<br>                    startActivity(intent);<br>                    return true;<br>                    }<br>                    return false;<br>                    }<br>                    });</p>
<p>同样，这里使用的是 Intent，底层的 IPC 由系统处理。</p>
<p>那么，什么时候需要显式实现 IPC 呢？以下是一些可能需要直接处理 IPC 的场景：</p>
<p>自定义系统服务<br>如果你在开发自定义 ROM 或系统级应用，可能需要创建新的系统服务，这时候就需要直接使用 AIDL（Android Interface Definition Language）来定义跨进程接口。</p>
<p>复杂的跨应用通信<br>当需要持续的、双向的、复杂的跨应用通信时，可能需要使用 AIDL 或 Messenger。</p>
<p>高性能要求的跨进程数据传输<br>对于需要频繁、大量数据传输的场景，可能需要使用共享内存（Shared Memory）等低级 IPC 机制。</p>
<p>自定义 Content Provider<br>虽然使用 Content Provider 的客户端不需要直接处理 IPC，但如果你在创建自己的 Content Provider，你需要考虑跨进程问题。</p>
<p>多进程应用<br>如果你的应用本身使用了多进程架构，你可能需要处理应用内不同进程间的通信。</p>
<p>特殊的进程间同步需求<br>某些需要精确控制进程间同步的场景可能需要直接使用底层 IPC 机制。</p>
<p>示例：使用 AIDL 的简单例子</p>
<p>定义 AIDL 接口：<br>Copy<br>&#x2F;&#x2F; IMyService.aidl<br>                    package com.example.app;</p>
<pre><code>                interface IMyService &#123;
                int add(int a, int b);
                &#125;
              
</code></pre>
<p>实现服务：<br>Copy<br>public class MyService extends Service {<br>                    private final IMyService.Stub binder &#x3D; new IMyService.Stub() {<br>                    @Override<br>                    public int add(int a, int b) {<br>                    return a + b;<br>                    }<br>                    };</p>
<pre><code>                @Override
                public IBinder onBind(Intent intent) &#123;
                return binder;
                &#125;
                &#125;
              
</code></pre>
<p>在客户端使用服务：<br>Copy<br>private IMyService myService;<br>                    private ServiceConnection connection &#x3D; new ServiceConnection() {<br>                    @Override<br>                    public void onServiceConnected(ComponentName<br>                      name, IBinder service) {<br>                    myService &#x3D; IMyService.Stub.asInterface(service);<br>                    try {<br>                    int result &#x3D; myService.add(3, 4);<br>                    Log.d(“IPC”, “Result: “ + result);<br>                    } catch (RemoteException e) {<br>                    e.printStackTrace();<br>                    }<br>                    }</p>
<pre><code>                @Override
                public void onServiceDisconnected(ComponentName
                  name) &#123;
                myService = null;
                &#125;
                &#125;;

                // 绑定服务
                bindService(new Intent(this, MyService.class),
                connection, Context.BIND_AUTO_CREATE);
              
</code></pre>
<p>总结：<br>在大多数常见的 Android 开发场景中，如分享功能或应用间跳转，我们通常不需要直接实现 IPC。Android 提供了高级抽象（如 Intent、Content Provider）来处理这些常见需求。只有在需要更精细控制、更高性能或更复杂的跨进程通信场景下，我们才需要考虑直接实现 IPC 机制。</p>
<p>就说一个具体场景吧：我想把我App生成的海报图片分享到微信朋友圈，那么这里应该涉及到1.跳转到微信 2.跳转到微信朋友圈的 待发表 Activity，对吧？那么这里我是怎样实现这样的需求？需要使用到Android系统以及微信的哪些API？</p>
<p>您提出了一个非常具体和实际的场景。分享图片到微信朋友圈确实是一个常见的需求。让我详细解释一下实现这个功能的步骤和所需的 API：</p>
<p>准备工作<br>首先，您需要在您的应用中集成微信 SDK。这不是 Android 系统 API 的一部分，而是微信提供的第三方 SDK。</p>
<p>下载微信 SDK：从微信开放平台下载 Android SDK。<br>在您的项目中添加 SDK 依赖。<br>在微信开放平台注册您的应用，获取 AppID。<br>实现分享功能<br>使用微信 SDK 提供的 API 来实现分享功能。以下是基本步骤：</p>
<p>Copy<br>import<br>                    com.tencent.mm.opensdk.modelmsg.SendMessageToWX;<br>                    import com.tencent.mm.opensdk.modelmsg.WXImageObject;<br>                    import com.tencent.mm.opensdk.modelmsg.WXMediaMessage;<br>                    import com.tencent.mm.opensdk.openapi.IWXAPI;<br>                    import com.tencent.mm.opensdk.openapi.WXAPIFactory;</p>
<pre><code>                public class ShareToWeChatActivity extends
                AppCompatActivity &#123;
                private IWXAPI api;
                private static final String APP_ID = &quot;your_wx_app_id&quot;;

                @Override
                protected void onCreate(Bundle
                  savedInstanceState) &#123;
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_share_to_wechat);

                // 初始化 WXAPI
                api = WXAPIFactory.createWXAPI(this, APP_ID, true);
                api.registerApp(APP_ID);
                &#125;

                private void shareImageToWeChatMoments(Bitmap
                  bitmap) &#123;
                // 检查微信是否安装
                if (!api.isWXAppInstalled()) &#123;
                Toast.makeText(this, &quot;请先安装微信&quot;,
                Toast.LENGTH_SHORT).show();
                return;
                &#125;

                // 创建 WXImageObject 和 WXMediaMessage 对象
                WXImageObject imgObj = new WXImageObject(bitmap);
                WXMediaMessage msg = new WXMediaMessage();
                msg.mediaObject = imgObj;

                // 设置缩略图
                Bitmap thumbBmp = Bitmap.createScaledBitmap(bitmap, 100, 100, true);
                bitmap.recycle();
                msg.thumbData = bitmapToByteArray(thumbBmp);

                // 构造一个 Req
                SendMessageToWX.Req req = new SendMessageToWX.Req();
                req.transaction = buildTransaction(&quot;img&quot;);
                req.message = msg;
                req.scene = SendMessageToWX.Req.WXSceneTimeline; // 分享到朋友圈

                // 调用 api 接口发送数据到微信
                api.sendReq(req);
                &#125;

                private String buildTransaction(final String type) &#123;
                return (type == null) ?
                String.valueOf(System.currentTimeMillis()) : type + System.currentTimeMillis();
                &#125;

                private byte[]
                bitmapToByteArray(Bitmap bitmap) &#123;
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
                return baos.toByteArray();
                &#125;
                &#125;
              
</code></pre>
<p>处理回调<br>微信完成分享后会返回到您的应用。您需要在 AndroidManifest.xml 中声明一个 Activity 来处理这个回调：</p>
<p>Copy<br><activity
                      android:name=".wxapi.WXEntryActivity"
                      android:exported="true"
                      android:label="@string/app_name"
                      android:theme="@android:style/Theme.Translucent.NoTitleBar" /></p>
<p>然后实现这个 Activity：</p>
<p>Copy<br>public class WXEntryActivity extends Activity implements IWXAPIEventHandler {<br>                    private IWXAPI api;</p>
<pre><code>                @Override
                protected void onCreate(Bundle
                  savedInstanceState) &#123;
                super.onCreate(savedInstanceState);
                api = WXAPIFactory.createWXAPI(this, APP_ID, false);
                api.handleIntent(getIntent(), this);
                &#125;

                @Override
                protected void onNewIntent(Intent intent) &#123;
                super.onNewIntent(intent);
                setIntent(intent);
                api.handleIntent(intent, this);
                &#125;

                @Override
                public void onReq(BaseReq req) &#123;
                // 处理微信发来的请求
                &#125;

                @Override
                public void onResp(BaseResp resp) &#123;
                // 处理微信返回的结果
                switch (resp.errCode) &#123;
                case BaseResp.ErrCode.ERR_OK:
                // 分享成功
                break;
                case BaseResp.ErrCode.ERR_USER_CANCEL:
                // 用户取消
                break;
                case BaseResp.ErrCode.ERR_AUTH_DENIED:
                // 认证被否决
                break;
                default:
                // 未知错误
                break;
                &#125;
                finish();
                &#125;
                &#125;
              
</code></pre>
<p>关键点说明：</p>
<p>这里使用的是微信 SDK 提供的 API，而不是 Android 系统 API。<br>分享到朋友圈是通过设置 req.scene &#x3D; SendMessageToWX.Req.WXSceneTimeline 来实现的。<br>微信不提供直接跳转到”待发表”界面的 API，用户需要在微信内完成发表操作。<br>整个过程涉及到跨应用通信，但底层的 IPC 机制由微信 SDK 和 Android 系统处理，开发者不需要直接实现 IPC。<br>注意事项：</p>
<p>确保您的应用在微信开放平台正确注册，并获得了 AppID。<br>遵守微信的分享政策，不要滥用分享功能。<br>处理各种可能的错误情况，如微信未安装、网络问题等。<br>注意图片大小限制，过大的图片可能无法成功分享。<br>总结：<br>虽然这个过程涉及到跨应用通信，但thanks to微信 SDK 和 Android 的 Intent 机制，我们不需要直接处理底层的 IPC。整个过程对开发者来说相对简单，主要是使用微信提供的 API 和处理相应的回调。</p>
<p>准确的说，当我的App继承了微信SDK，那么由这个微信SDK与通过Android系统与微信App进行进程间通信，是这个意思吗？</p>
<p>您的理解非常准确！让我详细解释一下这个过程：</p>
<p>微信 SDK 的角色<br>当您的应用集成了微信 SDK 后，这个 SDK 实际上充当了您的应用与微信应用之间的桥梁。微信 SDK 封装了与微信应用通信所需的复杂逻辑。</p>
<p>进程间通信的实现<br>微信 SDK 在底层确实使用了 Android 系统提供的 IPC 机制来与微信应用进行通信。具体来说，它主要利用了以下 Android 系统机制：</p>
<p>a. Intent 机制：用于启动微信应用的特定组件。<br>b. ContentProvider：可能用于数据交换。<br>c. AIDL (Android Interface Definition Language)：用于定义复杂的跨进程接口。</p>
<p>通信流程<br>当您调用微信 SDK 的方法（如分享到朋友圈）时，大致流程如下：</p>
<p>a. 您的应用调用微信 SDK 的方法。<br>b. 微信 SDK 准备必要的数据。<br>c. 微信 SDK 使用 Android 的 IPC 机制（主要是 Intent）向微信应用发送请求。<br>d. Android 系统接收这个 Intent，并将其传递给微信应用。<br>e. 微信应用处理这个请求，执行相应的操作（如打开分享界面）。<br>f. 操作完成后，微信应用通过类似的方式将结果返回给您的应用。</p>
<p>示例代码解析<br>让我们再看看之前的代码片段：</p>
<p>Copy<br>SendMessageToWX.Req req &#x3D; new SendMessageToWX.Req();<br>                    req.transaction &#x3D; buildTransaction(“img”);<br>                    req.message &#x3D; msg;<br>                    req.scene &#x3D; SendMessageToWX.Req.WXSceneTimeline;</p>
<pre><code>                api.sendReq(req);
              
</code></pre>
<p>这里的 api.sendReq(req) 方法实际上是在底层使用 Android 的 IPC 机制（很可能是通过发送特定的 Intent）来与微信应用通信。</p>
<p>回调处理<br>当您实现 WXEntryActivity 来处理微信的回调时，这也是利用了 Android 的 IPC 机制。微信应用会通过 Intent 启动您应用中的这个 Activity，从而将结果传递回来。</p>
<p>总结：<br>您的理解是正确的。当您的应用集成微信 SDK 后，确实是由这个 SDK 通过 Android 系统提供的 IPC 机制与微信应用进行进程间通信。这种设计使得复杂的跨应用通信对开发者来说变得相对简单和透明，因为所有的底层 IPC 细节都被封装在了 SDK 中。开发者只需要关注 SDK 提供的高级 API，而不需要直接处理复杂的 IPC 逻辑。</p>
<p>那么SDK的作用就应该是软件开发过程中的一种中间桥梁，SDK总是由系统提供方、大型软件提供方、硬件提供方，这些SDK来源方把功能底层实现的细节进行了封装，对外只是公开一个调用的方法，比如Android系统、微信&#x2F;支付宝&#x2F;飞书&#x2F;小红书、大疆无人机等来提供，一般的开发者只是调用SDK里面有的这些上层API来搭建需要的功能？</p>
<p>您的理解非常准确！SDK（Software Development Kit，软件开发工具包）确实在软件开发过程中扮演着重要的中间桥梁角色。您的描述很好地概括了 SDK 的本质和作用。让我进一步阐述和补充一些细节：</p>
<p>SDK 的本质</p>
<p>封装复杂性：SDK 封装了底层实现的复杂细节。<br>提供简化接口：对外提供简单、统一的 API。<br>跨平台兼容：有些 SDK 提供跨平台的兼容性。<br>SDK 的主要提供方</p>
<p>操作系统提供商：如 Android SDK、iOS SDK、Windows SDK。<br>大型软件公司：如微信 SDK、支付宝 SDK、Facebook SDK。<br>硬件制造商：如大疆无人机 SDK、各种 IoT 设备 SDK。<br>云服务提供商：如 AWS SDK、Google Cloud SDK、Azure SDK。<br>开源项目：许多开源项目也提供 SDK 以方便集成。<br>SDK 的主要功能</p>
<p>简化开发：开发者无需了解底层实现细节。<br>标准化接口：提供统一的接口，便于维护和更新。<br>安全性：通过 SDK 可以控制对敏感功能的访问。<br>性能优化：SDK 通常经过优化，提供高效的实现。<br>文档和支持：通常伴随详细的文档和技术支持。<br>SDK 使用示例</p>
<p>Android 系统 SDK：</p>
<p>Copy<br>&#x2F;&#x2F; 使用 Android SDK 创建一个<br>                          Intent<br>                        Intent intent &#x3D; new Intent(this,<br>                        SecondActivity.class);<br>                        startActivity(intent);</p>
<p>微信 SDK：</p>
<p>Copy<br>&#x2F;&#x2F; 使用微信 SDK 分享内容<br>                        WXWebpageObject webpage &#x3D; new WXWebpageObject();<br>                        webpage.webpageUrl &#x3D; “<a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a>“;<br>                        WXMediaMessage msg &#x3D; new WXMediaMessage(webpage);<br>                        msg.title &#x3D; “网页标题”;<br>                        msg.description &#x3D; “网页描述”;<br>                        SendMessageToWX.Req req &#x3D; new SendMessageToWX.Req();<br>                        req.transaction &#x3D; String.valueOf(System.currentTimeMillis());<br>                        req.message &#x3D; msg;<br>                        req.scene &#x3D; SendMessageToWX.Req.WXSceneTimeline;<br>                        api.sendReq(req);</p>
<p>大疆无人机 SDK：</p>
<p>Copy<br>&#x2F;&#x2F; 使用大疆 SDK 控制无人机起飞<br>                        mFlightController.startTakeoff(new CommonCallbacks.CompletionCallback() {<br>                        @Override<br>                        public void onResult(DJIError<br>                          djiError) {<br>                        if (djiError &#x3D;&#x3D; null) {<br>                        &#x2F;&#x2F; 起飞成功<br>                        } else {<br>                        &#x2F;&#x2F; 处理错误<br>                        }<br>                        }<br>                        });</p>
<p>SDK 的优势</p>
<p>减少开发时间和成本<br>提高代码质量和可靠性<br>确保与特定平台或服务的兼容性<br>获得持续的更新和支持<br>注意事项</p>
<p>版本兼容性：需要注意 SDK 版本与目标平台的兼容性。<br>性能影响：引入 SDK 可能会增加应用的大小和复杂度。<br>依赖性：过度依赖第三方 SDK 可能带来风险。<br>学习成本：每个 SDK 都有其特定的使用方法和最佳实践。<br>总结：<br>您的理解非常正确。SDK indeed是由系统提供方、大型软件提供方、硬件提供方等开发并提供的，它们封装了复杂的底层实现，为开发者提供了简化的上层 API。这使得开发者能够更容易地集成特定功能，而无需深入了解底层细节。这种方式极大地提高了开发效率，也促进了生态系统的发展。作为一个开发者，熟练使用各种 SDK 并了解它们的特性和限制，是构建现代应用程序的关键技能之一。</p>
<p>刚才我在上面说了“我想实现上传手机系统相册的图片或者视频到服务器。”的实现步骤，那么你分析一下第三方SDKio.github.lucksiege:pictureselector是不是也是这种实现步骤呢？</p>
<p>您提到的 io.github.lucksiege:pictureselector 是一个非常流行的开源图片选择器库，用于在 Android 应用中实现图片和视频选择功能。让我们分析一下这个库的实现步骤，并与您之前描述的过程进行比较：</p>
<p>获取系统相册内容：<br>PictureSelector 库确实使用了类似的方法来获取系统相册的内容。它主要使用 ContentResolver 和 MediaStore API 来查询设备上的媒体文件。</p>
<p>Copy<br>ContentResolver resolver &#x3D;<br>                    context.getContentResolver();<br>                    Uri uri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;<br>                    Cursor cursor &#x3D; resolver.query(uri, projection, selection, selectionArgs,<br>                    sortOrder);</p>
<p>这个过程与您之前描述的过程非常相似，都是利用 Android 系统提供的 ContentProvider 机制来访问媒体文件。</p>
<p>用户界面和选择过程：<br>PictureSelector 提供了一个预构建的用户界面，用于显示和选择媒体文件。这部分功能封装在库内部，简化了开发过程。</p>
<p>Copy<br>PictureSelector.create(this)<br>                    .openGallery(PictureMimeType.ofImage())<br>                    .forResult(new OnResultCallbackListener<LocalMedia>() {<br>                    @Override<br>                    public void onResult(List<LocalMedia><br>                      result) {<br>                    &#x2F;&#x2F; 处理选择的图片<br>                    }</p>
<pre><code>                @Override
                public void onCancel() &#123;
                // 用户取消选择
                &#125;
                &#125;);
              
</code></pre>
<p>这一步骤简化了您之前描述的在 UI 列表中选择图片的过程。</p>
<p>处理选择结果：<br>选择完成后，PictureSelector 会返回选中的媒体文件信息，这些信息可以直接用于后续的上传操作。</p>
<p>上传到服务器：<br>PictureSelector 本身不处理上传过程，但它提供了选中文件的路径等信息，方便您进行后续的上传操作。上传过程通常需要您自己实现，可能会用到类似 OkHttp 或 Retrofit 这样的网络库。</p>
<p>Copy<br>&#x2F;&#x2F; 假设使用 OkHttp 进行上传<br>                    OkHttpClient client &#x3D; new OkHttpClient();<br>                    RequestBody requestBody &#x3D; new MultipartBody.Builder()<br>                    .setType(MultipartBody.FORM)<br>                    .addFormDataPart(“file”, file.getName(),<br>                    RequestBody.create(MediaType.parse(“image&#x2F;*”), file))<br>                    .build();</p>
<pre><code>                Request request = new Request.Builder()
                .url(&quot;your_upload_url&quot;)
                .post(requestBody)
                .build();

                client.newCall(request).enqueue(new Callback() &#123;
                // 处理上传结果
                &#125;);
              
</code></pre>
<p>权限处理：<br>PictureSelector 库也处理了必要的权限请求，如读取外部存储的权限。</p>
<p>Copy<br>PictureSelector.create(this)<br>                    .openGallery(PictureMimeType.ofImage())<br>                    .isWeChatStyle(true)<br>                    .loadImageEngine(GlideEngine.createGlideEngine())<br>                    .forResult(PictureConfig.CHOOSE_REQUEST);</p>
<p>比较：</p>
<p>简化的 API：PictureSelector 提供了更高级的 API，封装了很多底层细节。<br>预构建的 UI：提供了现成的用户界面，减少了自定义 UI 的工作。<br>功能丰富：包含了图片裁剪、压缩等额外功能。<br>兼容性：处理了不同 Android 版本的兼容性问题。<br>权限处理：自动处理了必要的权限请求。<br>总结：<br>PictureSelector 库确实遵循了类似的实现步骤，但它提供了更高级的抽象和更多的功能。它简化了媒体文件选择的过程，使得开发者可以更容易地实现这个功能。然而，上传到服务器的部分仍然需要开发者自己实现。</p>
<p>这个库是一个很好的例子，展示了如何通过封装复杂的底层操作（如访问媒体存储、处理权限、创建用户界面等）来提供一个简单易用的 API，这正是我们之前讨论的 SDK 的典型特征。</p>
<p>我说下我的以下洞察：1.要执行一段代码（比如计算1-100之中所有整数的和）必须把这段代码放到一个线程当中，比如Java程序放到main()中或者new Thread，Android也是相似的逻辑（要么在默认的UI主线程，要么new Thread一个子线程），其他程序比如Python TypeScript等应该也是相同的逻辑？2.我们开发者实际是通过线程这个载体来与CPU等底层硬件打交道，不然调用SDK中的API无法运行？以Java程序为例，Thread就是线程，在它中应该定义了足够的native方法来直接更底层C&#x2F;C++打交道，再通过C&#x2F;C++操作底层硬件（比如CPU、IO等），我的理解正确且准确吗？</p>
<p>您的洞察非常深刻，展现了对计算机系统和编程模型的良好理解。让我们逐点分析您的洞察：</p>
<p>代码执行和线程<br>您的理解基本正确，但需要一些细微的调整和补充：</p>
<p>正确的部分：</p>
<p>所有代码确实都需要在某个线程中执行。<br>Java、Android、Python、TypeScript（在 Node.js 环境下）等确实都遵循类似的线程模型。<br>需要补充的部分：</p>
<p>单线程环境：某些环境（如浏览器中的 JavaScript）主要是单线程的，但它们使用事件循环来模拟并发。<br>隐式线程：很多时候，主线程是隐式创建的，开发者不需要显式定义。<br>协程：一些语言（如 Python、Kotlin）提供了协程，这是一种轻量级的并发单元。<br>线程、SDK 和硬件交互<br>您的理解大体正确，但让我们更详细地探讨这个问题：</p>
<p>正确的部分：</p>
<p>线程确实是我们与底层系统交互的一个重要抽象。<br>Java 的 Thread 类确实包含 native 方法来与底层系统交互。<br>需要补充和澄清的部分：</p>
<p>操作系统的角色：线程实际上是由操作系统管理的。Java 的 Thread 类通过 JNI（Java Native Interface）调用操作系统的线程 API。<br>硬件抽象层：操作系统提供了硬件抽象层，大多数高级语言（包括 Java）不直接与硬件交互，而是通过操作系统提供的 API。<br>SDK 和 API：许多 SDK 和 API 确实需要在线程中执行，但它们本身可能不直接创建线程。它们利用调用它们的线程来执行操作。<br>更准确的描述可能是：</p>
<p>代码执行和线程：<br>“所有代码都在某种形式的执行上下文中运行，通常是线程。在许多编程环境中，主线程是默认提供的，而其他线程可以显式创建。不同语言和平台可能有不同的并发模型，包括传统的线程、事件循环、协程等。”</p>
<p>线程、SDK 和硬件交互：<br>“线程是操作系统提供的一个抽象，允许程序并发执行多个任务。高级语言（如 Java）通过其运行时环境和本地接口（如 JNI）与操作系统的线程 API 交互。SDK 和 API 通常在现有线程上执行，利用操作系统提供的服务来间接与硬件交互。直接的硬件交互通常由操作系统内核或设备驱动程序处理。”</p>
<p>总结：<br>您的理解展示了对底层系统工作原理的良好洞察。虽然有一些需要细化的地方，但您已经抓住了核心概念。理解这些概念对于编写高效、可靠的软件非常重要，特别是在处理并发和系统级编程时。继续保持这种探究底层原理的好奇心，这将帮助您成为一个更优秀的开发者。</p>
<p>我有以下疑惑：1.你说 所有代码都在某种形式的执行上下文中运行，通常是线程。那意思还有不是在线程运行的代码？那这里的特例是不是指的是没有线程概念的编程语言？或者说还有其他可以承载代码执行的语言，比如python、kotlin就有协程可以承载代码的执行？2.你说 高级语言（如 Java）通过其运行时环境和本地接口（如 JNI）与操作系统的线程 API 交互。 这里的 运行时环境 是不是指的线程？还是啥？（进程？）还有 线程API 也就是说系统API为了能够随时可用也是运行在线程中的？3.我想到了服务，服务可以理解成生命周期跟应用程序或者系统生命周期一致的线程或者进程吗？因为我感觉它一般一直运行，除非程序或者系统挂掉？</p>
<p>您提出了一些非常深入和有趣的问题。让我们逐一解答：</p>
<p>执行上下文和线程<br>您的疑问很好。确实，并非所有代码都在传统意义上的”线程”中运行。让我解释一下：</p>
<p>特例：<br>a) 协程：如您所说，Python、Kotlin 等语言的协程是一种轻量级的并发单元，可以在单个线程内切换执行。<br>b) 事件循环：JavaScript 在浏览器中主要使用单线程加事件循环模型。<br>c) 函数式编程语言：某些纯函数式语言可能使用不同的执行模型。</p>
<p>执行上下文：<br>这个术语更广泛，包括线程、协程、事件循环中的任务等。本质上，它是代码执行时的环境。</p>
<p>运行时环境、JNI 和线程 API<br>运行时环境：<br>这不是指线程，而是指语言的执行环境。例如，Java 的运行时环境包括 JVM（Java Virtual Machine），它管理内存、执行字节码、处理线程等。</p>
<p>JNI（Java Native Interface）：<br>这是 Java 与本地（通常是 C&#x2F;C++）代码交互的机制。</p>
<p>线程 API：<br>操作系统提供的线程 API 是系统调用，不是持续运行的线程。当程序需要创建或管理线程时，它会调用这些 API。</p>
<p>服务和生命周期<br>您对服务的理解基本正确，但需要一些澄清：</p>
<p>服务不完全等同于线程或进程，而是一个可以在后台长时间运行的组件。<br>服务可以在自己的进程中运行，也可以在应用的主进程中运行。<br>服务的生命周期通常比普通活动（如 Android 的 Activity）长，但不一定与应用或系统的生命周期完全一致。<br>服务可以被系统在内存不足时终止，然后在条件允许时重新启动。<br>补充说明：</p>
<p>关于执行上下文：<br>即使在没有显式线程概念的语言中，代码仍然需要某种执行环境。例如，在单线程事件循环模型中，代码是在事件循环的迭代中执行的。</p>
<p>关于运行时环境：<br>运行时环境提供了程序执行所需的所有支持，包括内存管理、线程管理、异常处理等。它是程序和操作系统之间的中间层。</p>
<p>关于服务：<br>服务是一个应用组件概念，特别是在 Android 中。它可以在后台执行长时间运行的操作，但它的实现可能涉及一个或多个线程，具体取决于其设计和需求。</p>
<p>总结：<br>您的问题触及了一些计算机科学中非常深入和复杂的概念。理解这些概念对于成为一个优秀的开发者非常重要。执行模型、运行时环境、线程和进程这些概念的交互构成了现代软件系统的基础。继续保持这种探究精神，它将帮助您更深入地理解软件开发的各个层面。</p>
<p>你上面说的系统调用应该就是你说的硬件抽象层（实际就是API，通常使用C&#x2F;C++实现，因为最接近底层汇编语言），而要调用这些系统API就需要在我应用层创建的线程中（比如在Java通过JNI），这应该就是 线程API 名词的来源吧？</p>
<p>您的理解非常接近本质，但让我们再稍微深入一些，以确保概念完全清晰：</p>
<p>系统调用和硬件抽象层<br>系统调用（System Calls）：这是操作系统内核提供的接口，允许用户空间程序请求内核服务。例如，创建文件、读写数据、网络通信等都需要通过系统调用。</p>
<p>硬件抽象层（HAL）：这是一个更低级的概念，主要用于抽象硬件细节，使得操作系统能够在不同硬件上运行。HAL 通常是操作系统内部的一部分，不直接暴露给应用程序。</p>
<p>API 和系统调用<br>API（应用程序接口）：这是更高级的接口，通常由编程语言或库提供。API 可能直接映射到系统调用，也可能是更高级的抽象。</p>
<p>系统 API：这通常指操作系统提供的高级 API，它们可能封装了一个或多个系统调用。</p>
<p>线程 API<br>“线程 API” 这个术语通常指操作系统或编程语言提供的用于创建和管理线程的接口。</p>
<p>在底层，这些 API 确实会转化为系统调用。例如，在 POSIX 系统中，pthread_create() 函数最终会调用 clone() 或 fork() 系统调用。</p>
<p>Java 和 JNI<br>Java 通过 JNI 调用本地方法，这些本地方法可能直接或间接使用系统调用。</p>
<p>当 Java 程序创建线程时，JVM 会通过 JNI 调用操作系统的线程创建 API，这最终会转化为相应的系统调用。</p>
<p>应用层和系统层的交互<br>您的应用代码运行在用户空间的线程中。</p>
<p>当您的代码需要执行一些需要特权的操作（如文件 I&#x2F;O、网络通信等）时，它会通过系统 API 或直接的系统调用切换到内核空间执行这些操作。</p>
<p>这个切换过程涉及到从用户空间到内核空间的上下文切换。</p>
<p>总结：</p>
<p>您的理解基本正确。应用程序确实需要通过线程（或其他执行上下文）来调用系统 API 或发起系统调用。”线程 API” 是指用于管理线程的高级接口，这些接口在底层通常会转化为系统调用。</p>
<p>重要的是要理解，系统调用、API、和硬件抽象层是不同层次的抽象：</p>
<p>硬件抽象层：最底层，直接与硬件交互。<br>系统调用：操作系统内核提供的接口。<br>系统 API：操作系统提供的高级接口，可能封装了多个系统调用。<br>编程语言 API：如 Java 的线程 API，它们在底层可能使用 JNI 调用系统 API 或系统调用。<br>您的思考展示了对系统架构的深入理解，这对于开发高效、可靠的软件非常重要。继续保持这种探究底层原理的态度，它将帮助您成为一个更优秀的开发者。</p>
<p>假设我在Java语言中，那我是否可以通过native方法，通过jni调用系统API，来进行系统调用？利用系统调用来操作硬件抽象层，进而操作硬件，比如IO操作呢？打印机就是一个具体的例子吧？</p>
<p>您的理解非常正确！您已经很好地把握了从高级语言到硬件操作的整个过程。让我们详细探讨这个过程，并以打印机为例来说明：</p>
<p>Java 中的 native 方法<br>在 Java 中，您可以声明 native 方法，这些方法的实现是用其他语言（通常是 C 或 C++）编写的。</p>
<p>Copy<br>public class PrinterManager {<br>                    public native boolean printDocument(String document);</p>
<pre><code>                static &#123;
                System.loadLibrary(&quot;printer_native&quot;);
                &#125;
                &#125;
              
</code></pre>
<p>JNI 实现<br>在 C&#x2F;C++ 中实现这个 native 方法：</p>
<p>Copy<br>#include<br>                      &lt;jni.h&gt;<br>                    #include “PrinterManager.h”<br>                    #include &lt;windows.h&gt; &#x2F;&#x2F; 假设是 Windows<br>                        系统</p>
<pre><code>                JNIEXPORT jboolean JNICALL Java_PrinterManager_printDocument
                (JNIEnv *env, jobject obj, jstring document) &#123;
                const char *nativeString =
                (*env)-&gt;GetStringUTFChars(env, document, 0);

                // 调用 Windows API 进行打印
                BOOL success = SendToPrinter(nativeString);

                (*env)-&gt;ReleaseStringUTFChars(env, document, nativeString);
                return success ? JNI_TRUE : JNI_FALSE;
                &#125;
              
</code></pre>
<p>系统 API 调用<br>在上面的 C 代码中，SendToPrinter 可能是一个封装了 Windows 打印 API 的函数：</p>
<p>Copy<br>BOOL SendToPrinter(const char*<br>                      document) {<br>                    HANDLE hPrinter;<br>                    DOC_INFO_1 docInfo;<br>                    &#x2F;&#x2F; 打开打印机<br>                    if (!OpenPrinter(“Your Printer<br>                      Name”, &amp;hPrinter, NULL)) return FALSE;</p>
<pre><code>                // 开始文档打印
                docInfo.pDocName = &quot;My Document&quot;;
                docInfo.pOutputFile = NULL;
                docInfo.pDatatype = &quot;RAW&quot;;
                if (StartDocPrinter(hPrinter, 1,
                (LPBYTE)&amp;docInfo) == 0) &#123;
                ClosePrinter(hPrinter);
                return FALSE;
                &#125;

                // 开始页面打印
                if (!StartPagePrinter(hPrinter)) &#123;
                EndDocPrinter(hPrinter);
                ClosePrinter(hPrinter);
                return FALSE;
                &#125;

                // 写入打印数据
                DWORD dwBytesWritten;
                WritePrinter(hPrinter, document, strlen(document),
                &amp;dwBytesWritten);

                // 结束打印
                EndPagePrinter(hPrinter);
                EndDocPrinter(hPrinter);
                ClosePrinter(hPrinter);

                return TRUE;
                &#125;
              
</code></pre>
<p>系统调用<br>上面的 Windows API 函数（如 OpenPrinter, WritePrinter 等）在内部会转换为相应的系统调用。这些系统调用会切换到内核模式，与打印机驱动程序交互。</p>
<p>硬件抽象层和硬件操作<br>打印机驱动程序是硬件抽象层的一部分。它知道如何将通用的打印命令转换为特定打印机型号所需的指令。这些指令最终通过适当的硬件接口（如 USB 或网络）发送到打印机硬件。</p>
<p>整个过程总结：</p>
<p>Java 代码 -&gt; JNI -&gt; C&#x2F;C++ 代码 -&gt; 系统 API -&gt; 系统调用 -&gt; 内核 -&gt; 驱动程序 -&gt; 硬件</p>
<p>这个例子很好地展示了从高级语言到硬件操作的整个过程：</p>
<p>Java 代码提供了一个高级、平台无关的接口。<br>JNI 允许 Java 与平台特定的 C&#x2F;C++ 代码交互。<br>C&#x2F;C++ 代码调用操作系统特定的 API。<br>这些 API 在底层转换为系统调用。<br>系统调用切换到内核模式，与驱动程序交互。<br>驱动程序（作为硬件抽象层的一部分）知道如何与特定硬件通信。<br>您的理解非常准确，这个过程确实展示了如何从高级语言一直到硬件级别的操作。这种分层设计允许开发者在高级抽象上工作，同时仍然能够在需要时访问底层功能。理解这个过程对于开发高效、可靠的软件，特别是需要与硬件交互的软件，非常重要。</p>
<p>我现在又有一个疑惑就是，假如在Android开发中我要在一个Activity与某个服务进行通信，这个服务可能是自定义的推送服务也可能是系统通知等，那么我与这个服务进行的通信是否跨线程或者跨进程？还是要分情况讨论分析？</p>
<p>您提出了一个非常好的问题，这确实需要分情况讨论。在 Android 中，Activity 与服务之间的通信方式取决于服务的类型和位置。让我们详细分析不同的情况：</p>
<p>同进程服务<br>如果服务和 Activity 在同一个应用进程中运行：</p>
<p>通信方式：可以直接通过方法调用或者使用 LocalBroadcastManager 进行通信。<br>是否跨线程：可能跨线程，但不跨进程。<br>示例：<br>Copy<br>&#x2F;&#x2F; 在 Activity 中<br>                    Intent intent &#x3D; new Intent(this,<br>                    MyLocalService.class);<br>                    bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</p>
<pre><code>                private ServiceConnection serviceConnection = new ServiceConnection() &#123;
                @Override
                public void onServiceConnected(ComponentName
                  name, IBinder service) &#123;
                MyLocalService.LocalBinder binder
                = (MyLocalService.LocalBinder) service;
                myService = binder.getService();
                // 现在可以直接调用服务的方法
                &#125;
                // ...
                &#125;;
              
</code></pre>
<p>不同进程的自定义服务<br>如果服务在不同的进程中运行：</p>
<p>通信方式：需要使用 IPC（进程间通信）机制，如 AIDL、Messenger 或 Binder。<br>是否跨进程：是的，这是跨进程通信。<br>示例（使用 AIDL）：<br>Copy<br>&#x2F;&#x2F; 在 AIDL 文件中定义接口<br>                    interface IMyAidlInterface<br>                    {<br>                    void someMethod(String data);<br>                    }</p>
<pre><code>                // 在 Activity 中
                private IMyAidlInterface myService;

                private ServiceConnection serviceConnection = new ServiceConnection() &#123;
                @Override
                public void onServiceConnected(ComponentName
                  name, IBinder service) &#123;
                myService = IMyAidlInterface.Stub.asInterface(service);
                // 现在可以通过 AIDL 接口调用服务的方法
                &#125;
                // ...
                &#125;;
              
</code></pre>
<p>系统服务（如通知服务）<br>对于系统服务：</p>
<p>通信方式：通过系统提供的 API 进行通信。<br>是否跨进程：是的，这通常涉及跨进程通信，但系统 API 隐藏了这些细节。<br>示例（使用通知服务）：<br>Copy<br>NotificationCompat.Builder builder &#x3D; new NotificationCompat.Builder(this, CHANNEL_ID)<br>                    .setSmallIcon(R.drawable.notification_icon)<br>                    .setContentTitle(“My notification”)<br>                    .setContentText(“Hello World!”)<br>                    .setPriority(NotificationCompat.PRIORITY_DEFAULT);</p>
<pre><code>                NotificationManagerCompat notificationManager =
                NotificationManagerCompat.from(this);
                notificationManager.notify(notificationId, builder.build());
              
</code></pre>
<p>广播<br>使用广播进行通信：</p>
<p>通信方式：通过发送和接收广播。<br>是否跨进程：可以是跨进程的，也可以是同进程的。<br>示例：<br>Copy<br>&#x2F;&#x2F; 发送广播<br>                    Intent intent &#x3D; new Intent(“com.example.MY_ACTION”);<br>                    intent.putExtra(“data”, “Hello”);<br>                    sendBroadcast(intent);</p>
<pre><code>                // 接收广播
                BroadcastReceiver receiver = new BroadcastReceiver() &#123;
                @Override
                public void onReceive(Context context, Intent
                  intent) &#123;
                String data = intent.getStringExtra(&quot;data&quot;);
                // 处理接收到的数据
                &#125;
                &#125;;
                registerReceiver(receiver, new IntentFilter(&quot;com.example.MY_ACTION&quot;));
              
</code></pre>
<p>总结：</p>
<p>同进程服务：通常不涉及跨进程通信，但可能涉及跨线程通信。<br>不同进程的自定义服务：涉及跨进程通信，需要使用 IPC 机制。<br>系统服务：涉及跨进程通信，但通过系统 API 隐藏了复杂性。<br>广播：可以是跨进程的，也可以是同进程的，取决于广播的类型和接收者。<br>在 Android 开发中，了解这些不同的通信场景和机制非常重要。它们各有优缺点和适用场景：</p>
<p>同进程通信更快，但限制了服务的复用性。<br>跨进程通信更灵活，但性能开销较大，且实现更复杂。<br>系统服务提供了标准化的接口，但可定制性较低。<br>广播适合一对多的通信，但不适合频繁或大量数据的传输。<br>选择合适的通信方式取决于您的具体需求，如性能要求、安全性考虑、跨应用通信的需求等。理解这些机制将帮助您设计出更高效、更可靠的 Android 应用。</p>
<p>在谈谈推送服务吧，这个应该涉及到了跨进程、跨线程通信吧？我的理解大致是推送SDK在底层跟Android系统进行跨进程通信（比如IPC），让Android系统专门为其打开一条网络消息接收通道（比如说底层通过WebSocket来实现），保持长连接，当有消息来的时候，SDK会通知集成了该SDK的应用进行UI更新。跨进程指的是推送SDK实现了Android系统进程和APP进程的通信；跨线程指的是SDK中监听消息是一个后台操作，和UI主线程应该不是同一个线程，因此是跨线程的，我的理解正确且准确吗？</p>
<p>您的理解非常接近推送服务的实际工作原理，展示了对Android系统架构和通信机制的深入理解。让我们进一步分析和补充一些细节：</p>
<p>推送SDK与系统的交互<br>您的理解基本正确。推送SDK确实需要与Android系统进行深度交互，但具体实现可能因不同的推送服务而略有不同。</p>
<p>系统级权限：许多推送SDK需要特殊的系统权限来保持后台运行和接收网络消息。<br>长连接维护：通常通过WebSocket或类似的长连接技术实现。<br>跨进程通信（IPC）<br>您的理解正确。推送服务通常涉及多个进程之间的通信：</p>
<p>推送服务进程 &lt;-&gt; 系统进程：用于保持服务运行和接收系统级事件。<br>推送服务进程 &lt;-&gt; 应用进程：用于将消息传递给应用。<br>这里通常使用Android的Binder机制或AIDL（Android Interface Definition Language）来实现IPC。</p>
<p>跨线程通信<br>您的理解也是正确的。推送服务确实涉及跨线程通信：</p>
<p>网络监听线程：负责保持长连接和接收消息。<br>消息处理线程：可能有专门的线程来处理接收到的消息。<br>UI线程：需要在主线程上更新UI。<br>具体实现细节<br>推送服务注册：应用启动时，通常会向推送SDK注册，这涉及到应用进程和推送服务进程的通信。<br>消息接收：推送服务接收到消息后，需要通知相应的应用。<br>唤醒机制：在某些情况下，推送服务可能需要唤醒已经被系统休眠的应用。<br>示例流程<br>Copy<br>&#x2F;&#x2F; 在应用中初始化推送SDK<br>                    PushSDK.init(this);</p>
<pre><code>                // 注册消息接收器
                PushSDK.registerPushReceiver(new PushReceiver() &#123;
                @Override
                public void onMessageReceived(String
                  message) &#123;
                // 这里通常运行在非UI线程
                runOnUiThread(() -&gt; &#123;
                // 更新UI
                updateUI(message);
                &#125;);
                &#125;
                &#125;);
              
</code></pre>
<p>补充说明<br>电源管理：推送服务需要特别注意电源消耗，通常会采用各种策略来平衡实时性和电池寿命。<br>多厂商适配：不同的Android设备厂商可能有自己的推送服务实现，需要进行适配。<br>系统限制：随着Android系统版本的更新，后台服务的限制越来越严格，推送服务需要不断适应这些变化。<br>总结：<br>您的理解非常准确。推送服务确实涉及复杂的跨进程和跨线程通信。它需要在系统级别、网络通信、进程间通信和线程管理等多个层面进行精细的设计和实现。您的分析展示了对Android系统架构和通信机制的深入理解，这对于开发高效、可靠的Android应用非常重要。</p>
<p>继续保持这种深入思考和分析的习惯，它将帮助您在Android开发领域取得更大的进步。特别是在处理复杂的系统级功能和性能优化时，这种深层次的理解将会非常有价值。</p>
<p>Android中的服务是不是运行在主线程当中？</p>
<p>您提出了一个非常好的问题，这个问题涉及到 Android 服务的一个常见误解。让我详细解释一下：</p>
<p>默认情况下，Android 服务确实运行在应用的主线程中<br>这意味着：</p>
<p>服务的生命周期方法（如 onCreate(), onStartCommand(), onBind(), onDestroy()）默认在主线程上执行。<br>如果在这些方法中执行耗时操作，可能会导致应用无响应（ANR - Application Not Responding）。<br>为什么设计成在主线程运行？<br>简化编程模型：不需要考虑线程同步问题。<br>方便与 UI 交互：可以直接更新 UI，不需要使用 Handler 或 runOnUiThread。<br>一致性：与 Activity 和 BroadcastReceiver 的行为一致。<br>但这并不意味着所有服务操作都必须在主线程上执行<br>服务可以（而且通常应该）创建工作线程来执行耗时操作。</p>
<p>Android 提供了几种方式来在服务中使用后台线程：</p>
<p>a. 在服务内创建新线程：</p>
<p>Copy<br>public class MyService extends Service {<br>                        @Override<br>                        public int onStartCommand(Intent intent,<br>                          int flags, int startId) {<br>                        new Thread(() -&gt; {<br>                        &#x2F;&#x2F; 执行耗时操作<br>                        }).start();<br>                        return START_STICKY;<br>                        }<br>                        }</p>
<p>b. 使用 AsyncTask（虽然在新版 Android 中已被弃用）：</p>
<p>Copy<br>public class MyService extends Service {<br>                        @Override<br>                        public int onStartCommand(Intent intent,<br>                          int flags, int startId) {<br>                        new AsyncTask&lt;Void,<br>                        Void, Void&gt;() {<br>                        @Override<br>                        protected Void doInBackground(Void…<br>                          voids) {<br>                        &#x2F;&#x2F; 执行耗时操作<br>                        return null;<br>                        }<br>                        }.execute();<br>                        return START_STICKY;<br>                        }<br>                        }</p>
<p>c. 使用 IntentService（在 API 26 之前）：<br>IntentService 会自动创建一个工作线程来处理传入的 Intent。</p>
<p>Copy<br>public class MyIntentService extends IntentService {<br>                        public MyIntentService() {<br>                        super(“MyIntentService”);<br>                        }</p>
<pre><code>                    @Override
                    protected void onHandleIntent(Intent
                      intent) &#123;
                    // 这里的代码会在工作线程中执行
                    &#125;
                    &#125;
                  
</code></pre>
<p>d. 使用 JobIntentService（API 26 及以上）：<br>JobIntentService 是 IntentService 的兼容性替代品。</p>
<p>Copy<br>public class MyJobIntentService<br>                        extends JobIntentService {<br>                        @Override<br>                        protected void onHandleWork(@NonNull Intent intent) {<br>                        &#x2F;&#x2F; 这里的代码会在工作线程中执行<br>                        }<br>                        }</p>
<p>特殊情况：前台服务<br>前台服务虽然也默认运行在主线程，但它们有更高的优先级，不太容易被系统杀死。然而，它们仍然应该避免在主线程上执行耗时操作。</p>
<p>最佳实践<br>在服务的生命周期方法中避免执行耗时操作。<br>对于需要长时间运行的任务，创建工作线程或使用 IntentService&#x2F;JobIntentService。<br>考虑使用 WorkManager 来调度和执行后台任务，特别是对于需要满足特定条件（如网络可用）才执行的任务。<br>总结：<br>虽然 Android 服务默认运行在主线程上，但这并不意味着所有的服务操作都应该在主线程上执行。理解这一点对于开发高性能、响应迅速的 Android 应用至关重要。在设计服务时，应该仔细考虑哪些操作需要在后台线程中执行，以避免阻塞主线程和潜在的 ANR 问题。</p>
<p>我有以下疑惑：1.我们需要收到调用GC的时候，GC一般会带来STW问题。什么叫STW问题？2.其中 MessageQueue 被 Looper 管理，Looper在构造时同步会创建 MessageQueue，并利用ThreadLocal 这种 TLS，将其与当前线程绑定。什么叫TLS？</p>
<p>您提出了两个非常好的问题，涉及到了内存管理和线程本地存储的概念。让我们逐一解答：</p>
<p>STW (Stop The World) 问题<br>STW 是指在垃圾收集（Garbage Collection, GC）过程中，Java 应用程序的所有线程都会暂停执行的现象。</p>
<p>定义：STW 字面意思就是”停止世界”，在 GC 上下文中，”世界”指的是 Java 应用程序。<br>原因：为了保证垃圾收集的正确性和一致性，GC 需要在一个稳定的堆状态下进行。<br>影响：STW 会导致应用程序暂时停止响应，可能会影响用户体验，特别是在大型应用或对实时性要求高的场景中。<br>STW 的具体表现：</p>
<p>所有应用线程被暂停。<br>GC 线程开始工作，清理内存。<br>清理完成后，应用线程恢复执行。<br>优化方法：</p>
<p>使用并发垃圾收集器（如 CMS、G1）可以减少 STW 时间。<br>合理设置堆大小和代的比例。<br>优化代码以减少对象创建和垃圾产生。<br>TLS (Thread Local Storage)<br>TLS 是一种线程本地存储机制，允许每个线程拥有自己的独立的变量副本。</p>
<p>定义：TLS 提供了一种方法，使得同一个变量在不同的线程中拥有不同的值。<br>作用：用于存储线程特有的数据，避免线程间的数据竞争。<br>在 Java 中，ThreadLocal 类实现了 TLS 机制：</p>
<p>Copy<br>public class ThreadLocalExample {<br>                    private static final ThreadLocal<Integer> threadLocalValue &#x3D; new ThreadLocal&lt;&gt;();</p>
<pre><code>                public static void main(String[] args) &#123;
                Thread t1 = new Thread(() -&gt; &#123;
                threadLocalValue.set(1);
                System.out.println(&quot;Thread 1: &quot; + threadLocalValue.get());
                &#125;);

                Thread t2 = new Thread(() -&gt; &#123;
                threadLocalValue.set(2);
                System.out.println(&quot;Thread 2: &quot; + threadLocalValue.get());
                &#125;);

                t1.start();
                t2.start();
                &#125;
                &#125;
              
</code></pre>
<p>在 Android 的 Looper 中使用 TLS 的原因：</p>
<p>每个线程都有自己的 Looper 和 MessageQueue。<br>使用 TLS 可以确保在任何地方都能获取到当前线程的 Looper，而不需要显式传递。<br>Looper 中 TLS 的使用示例：</p>
<p>Copy<br>public final class Looper {<br>                    static final<br>                    ThreadLocal<Looper> sThreadLocal &#x3D; new ThreadLocal<Looper>();</p>
<pre><code>                public static void prepare() &#123;
                if (sThreadLocal.get() != null)
                &#123;
                throw new RuntimeException(&quot;Only one Looper may
                  be created per thread&quot;);
                &#125;
                sThreadLocal.set(new Looper(true));
                &#125;

                public static Looper myLooper() &#123;
                return sThreadLocal.get();
                &#125;
                // ...
                &#125;
              
</code></pre>
<p>这种设计的优点：</p>
<p>线程安全：每个线程有自己的 Looper 实例，避免了线程间的数据竞争。<br>方便访问：在任何地方都可以通过 Looper.myLooper() 获取当前线程的 Looper。<br>解耦：不需要显式地在不同组件间传递 Looper 对象。<br>总结：</p>
<p>STW 是 GC 过程中的一个重要概念，理解它有助于优化应用性能，特别是在对响应时间敏感的场景中。<br>TLS（在 Java 中通过 ThreadLocal 实现）是一种重要的线程安全机制，在 Android 的消息循环系统中扮演着关键角色。<br>理解这些概念对于深入掌握 Java 和 Android 的内存管理和并发编程非常重要。它们帮助开发者编写更高效、更可靠的代码，尤其是在处理复杂的多线程场景时。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">JackAAAAA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/de362e30.html">http://example.com/posts/de362e30.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">jackAAAAA's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Claude/">Claude</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/f2c6e9a2.html" title="2024年5月31日-Java面试题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2024年5月31日-Java面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JackAAAAA</div><div class="author-info__description"> </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jackAAAAA"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jackAAAAA" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1143865523@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/de362e30.html" title="头脑中一些模糊概念与Claude 3.5 Sonnet的讨论">头脑中一些模糊概念与Claude 3.5 Sonnet的讨论</a><time datetime="2024-07-08T11:06:04.000Z" title="发表于 2024-07-08 19:06:04">2024-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f2c6e9a2.html" title="2024年5月31日-Java面试题">2024年5月31日-Java面试题</a><time datetime="2024-05-31T07:32:37.000Z" title="发表于 2024-05-31 15:32:37">2024-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7942b5c7.html" title="LeetCode_2644总结">LeetCode_2644总结</a><time datetime="2024-05-19T03:55:23.000Z" title="发表于 2024-05-19 11:55:23">2024-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e65909f7.html" title="自定义博客测试">自定义博客测试</a><time datetime="2024-05-17T02:53:18.000Z" title="发表于 2024-05-17 10:53:18">2024-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4a17b156.html" title="Hello World">Hello World</a><time datetime="2024-05-15T04:04:04.907Z" title="发表于 2024-05-15 12:04:04">2024-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By JackAAAAA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://www.jackAAAAA.github.io/">blog</a>! <a href="icp链接"><img class="icp-icon" src="icp图片"><span>备案号：xxxxxx</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>